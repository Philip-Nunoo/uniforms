(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{"./pages/API/ValidatedForm.mdx":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return g});var o=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/objectWithoutProperties.js"),t=a.n(o),r=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/classCallCheck.js"),l=a.n(r),i=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/createClass.js"),d=a.n(i),s=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"),m=a.n(s),c=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/getPrototypeOf.js"),u=a.n(c),h=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/inherits.js"),p=a.n(h),v=a("./node_modules/react/index.js"),f=a.n(v),b=a("./node_modules/@mdx-js/tag/dist/index.js"),g=function(e){function n(e){var a;return l()(this,n),(a=m()(this,u()(n).call(this,e))).layout=null,a}return p()(n,e),d()(n,[{key:"render",value:function(){var e=this.props,n=e.components;t()(e,["components"]);return f.a.createElement(b.MDXTag,{name:"wrapper",components:n},f.a.createElement(b.MDXTag,{name:"h2",components:n,props:{id:"validatedform"}},"ValidatedForm"),f.a.createElement(b.MDXTag,{name:"pre",components:n},f.a.createElement(b.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import ValidatedForm from 'uniforms/ValidatedForm'; // Or from the theme package.\n\n<ValidatedForm\n  // Additional asynchronous validation.\n  //   Schema validation has to be sync, so this is the only way to achieve\n  //   async validation.\n  onValidate={(model, error, callback) => {\n    // You can either ignore validation error...\n    if (omitValidation(model)) {\n      return callback(null);\n    }\n\n    // ...or any additional validation if an error is already there...\n    if (error) {\n      return callback();\n    }\n\n    // ...or feed it with another error.\n    MyAPI.validate(model, error => callback(error || null));\n  }}\n  // Validation mode.\n  //   By default, the form will start to validate from the time of the first\n  //   submit and then revalidate on every change. It's 'onChangeAfterSubmit'.\n  //   There are also 'onChange' and 'onSubmit' modes, but those are quite\n  //   self-explanatory.\n  validate=\"onChangeAfterSubmit\"\n  // Validator options.\n  //   It's passed to getValidator of your schema bridge. It really depends on\n  //   your schema.\n  validator={{clean: true}}\n  // Form methods.\n  ref={form => {\n    // Validate form with the current model.\n    //   Returns a Promise, which rejects with an validation error or\n    //   resolves without any value. Note, that it resolves/rejects AFTER\n    //   the component is rerendered.\n    form.validate();\n\n    // Validate form with key set to value.\n    //   You can use it to check, if a given value will pass the\n    //   validation or not. Returns validation Promise, as described above.\n    form.validate(key, value);\n\n    // Validate form with the given model.\n    //   Rather internal function. Returns validation Promise, as described\n    //   above.\n    form.validateModel(model);\n  }}\n/>;\n")),f.a.createElement(b.MDXTag,{name:"p",components:n},f.a.createElement(b.MDXTag,{name:"strong",components:n,parentName:"p"},"Note:")," All ",f.a.createElement(b.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"BaseForm")," props are also accepted and all methods are available."))}}]),n}(f.a.Component)}}]);
//# sourceMappingURL=pages-api-validated-form.7bdcc2e35d2d8e0f9848.js.map