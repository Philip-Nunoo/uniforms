(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{"./pages/Forms.mdx":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return T});var t=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/objectWithoutProperties.js"),o=a.n(t),m=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/classCallCheck.js"),r=a.n(m),s=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/createClass.js"),l=a.n(s),c=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"),p=a.n(c),i=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/getPrototypeOf.js"),d=a.n(i),u=a("./node_modules/docz-core/node_modules/@babel/runtime/helpers/inherits.js"),g=a.n(u),h=a("./node_modules/react/index.js"),M=a.n(h),E=a("./node_modules/@mdx-js/tag/dist/index.js"),T=function(e){function n(e){var a;return r()(this,n),(a=p()(this,d()(n).call(this,e))).layout=null,a}return g()(n,e),l()(n,[{key:"render",value:function(){var e=this.props,n=e.components;o()(e,["components"]);return M.a.createElement(E.MDXTag,{name:"wrapper",components:n},M.a.createElement(E.MDXTag,{name:"h1",components:n,props:{id:"forms"}},"Forms"),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"asynchronous-validation"}},"Asynchronous validation"),M.a.createElement(E.MDXTag,{name:"p",components:n},M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ValidatedForm")," (and so ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"AutoForm"),") has an ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onValidate")," prop. It can be used to create an asynchronous validation:"),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"const onValidate = (model, error, callback) => {\n  // You can either ignore validation error...\n  if (omitValidation(model)) {\n    return callback(null);\n  }\n\n  // ...or any additional validation if an error is already there...\n  if (error) {\n    return callback();\n  }\n\n  // ...or feed it with another error.\n  MyAPI.validate(model, error => callback(error || null));\n};\n\n// Later...\n\n<ValidatedForm {...props} onValidate={onValidate} />;\n")),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"autosave"}},"Autosave"),M.a.createElement(E.MDXTag,{name:"p",components:n},"Every form has an autosave functionality. If you set an ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"autosave")," prop, then every change will trigger a submit. There's also an ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"autosaveDelay")," prop - a minimum time between saves in milliseconds (default: ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"0"),")."),M.a.createElement(E.MDXTag,{name:"p",components:n},M.a.createElement(E.MDXTag,{name:"strong",components:n,parentName:"p"},"Example:")),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"<AutoForm\n  autosave\n  autosaveDelay={5000} // 5 seconds\n  schema={schema}\n  onSubmit={onSubmit}\n/>\n")),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"hierarchy"}},"Hierarchy"),M.a.createElement("p",{align:"center"},M.a.createElement("img",{src:"uniforms-graph.png"})),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"methods"}},"Methods"),M.a.createElement(E.MDXTag,{name:"p",components:n},"You can use ",M.a.createElement(E.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://facebook.github.io/react/docs/more-about-refs.html"}},"React ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"a"},"ref")," prop")," to manually access form methods. Example usage:"),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"const MyForm = ({schema, onSubmit}) => {\n  let formRef;\n\n  return (\n    <section>\n      <AutoForm ref={ref => (formRef = ref)} schema={schema} onSubmit={onSubmit} />\n      <small onClick={() => formRef.reset()}>Reset</small>\n      <small onClick={() => formRef.submit()}>Submit</small>\n    </section>\n  );\n};\n")),M.a.createElement(E.MDXTag,{name:"p",components:n},"All available methods:"),M.a.createElement(E.MDXTag,{name:"ul",components:n},M.a.createElement(E.MDXTag,{name:"li",components:n,parentName:"ul"},M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"change(key, value)")),M.a.createElement(E.MDXTag,{name:"li",components:n,parentName:"ul"},M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"reset()")),M.a.createElement(E.MDXTag,{name:"li",components:n,parentName:"ul"},M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"submit()")),M.a.createElement(E.MDXTag,{name:"li",components:n,parentName:"ul"},M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"validate()")," ",M.a.createElement(E.MDXTag,{name:"em",components:n,parentName:"li"},"(added in ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"em"},"ValidatedForm"),")"))),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"change-reactions"}},"Change reactions"),M.a.createElement(E.MDXTag,{name:"p",components:n},"If you want to make one field to influence others, simply extend ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"AutoForm")," and override ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onChange")," method."),M.a.createElement(E.MDXTag,{name:"p",components:n},M.a.createElement(E.MDXTag,{name:"strong",components:n,parentName:"p"},"Example:")),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"class ChainForm extends AutoForm {\n  onChange(key, value) {\n    if (key === 'key_to_intercept') return;\n    if (key === 'key_to_translate') return super.onChange('another_key', value);\n    if (key === 'key_to_mutate') {\n      super.onChange('another_key1', value * 2);\n      super.onChange('another_key2', value / 2);\n      return;\n    }\n\n    super.onChange(key, value);\n  }\n}\n")),M.a.createElement(E.MDXTag,{name:"p",components:n},"It can be easily applied multiple times to make your forms even more reusable."),M.a.createElement(E.MDXTag,{name:"p",components:n},M.a.createElement(E.MDXTag,{name:"strong",components:n,parentName:"p"},"Example:")),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"const withMultipliedField = (fieldA, fieldB, Form) =>\n  class withMultipliedFieldForm extends Form {\n    onChange(key, value) {\n      // Multiply fieldA\n      if (key === fieldA) super.onChange(fieldB, value + value);\n\n      // Pass every change\n      super.onChange(key, value);\n    }\n  };\n")),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"model-transformations"}},"Model transformations"),M.a.createElement(E.MDXTag,{name:"p",components:n},"If you need to transform model before it will be validated, submitted or passed down to the fields, there's a ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"modelTransform")," prop, which should be used in those use cases."),M.a.createElement(E.MDXTag,{name:"p",components:n},M.a.createElement(E.MDXTag,{name:"strong",components:n,parentName:"p"},"Example:")),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"<AutoForm\n  // Do not mutate given model!\n  modelTransform={(mode, model) => {\n    // This model will be passed to the fields.\n    if (mode === 'form') {\n      /* ... */\n    }\n\n    // This model will be submitted.\n    if (mode === 'submit') {\n      /* ... */\n    }\n\n    // This model will be validated.\n    if (mode === 'validate') {\n      /* ... */\n    }\n\n    // Otherwise, return unaltered model.\n    return model;\n  }}\n  onSubmit={onSubmit}\n  schema={schema}\n/>\n")),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"post-submit-handling"}},"Post-submit handling"),M.a.createElement(E.MDXTag,{name:"p",components:n},"It's a good UX practice to tell your users that something failed or succeed. To make it simpler, there are ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onSubmitFailure")," and ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onSubmitSuccess")," props."),M.a.createElement(E.MDXTag,{name:"p",components:n},M.a.createElement(E.MDXTag,{name:"strong",components:n,parentName:"p"},"Example:")),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"<AutoForm\n  schema={schema}\n  onSubmit={doc => db.saveThatReturnsPromise(doc)}\n  onSubmitSuccess={() => alert('Promise resolved!')}\n  onSubmitFailure={() => alert('Promise rejected!')}\n/>\n")),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"validation-options-and-modes"}},"Validation options and modes"),M.a.createElement(E.MDXTag,{name:"p",components:n},"Any form can be validated in one those three styles:"),M.a.createElement(E.MDXTag,{name:"ul",components:n},M.a.createElement(E.MDXTag,{name:"li",components:n,parentName:"ul"},M.a.createElement(E.MDXTag,{name:"p",components:n,parentName:"li"},M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onChange"),"\nValidate on every change.")),M.a.createElement(E.MDXTag,{name:"li",components:n,parentName:"ul"},M.a.createElement(E.MDXTag,{name:"p",components:n,parentName:"li"},M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onChangeAfterSubmit")," ",M.a.createElement(E.MDXTag,{name:"em",components:n,parentName:"p"},"(default)"),"\nValidate on every change, but only after first submit.")),M.a.createElement(E.MDXTag,{name:"li",components:n,parentName:"ul"},M.a.createElement(E.MDXTag,{name:"p",components:n,parentName:"li"},M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onSubmit"),"\nValidate on every submit."))),M.a.createElement(E.MDXTag,{name:"p",components:n},"If your schema validator accepts any options, those can be passed in ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"validator")," prop."),M.a.createElement(E.MDXTag,{name:"p",components:n},M.a.createElement(E.MDXTag,{name:"strong",components:n,parentName:"p"},"Example:")),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'<AutoForm validate="onChange" validator={validatorOptions} schema={schema} onSubmit={onSubmit} />\n')),M.a.createElement(E.MDXTag,{name:"h2",components:n,props:{id:"example-modifierform"}},"Example: ",M.a.createElement(E.MDXTag,{name:"inlineCode",components:n,parentName:"h2"},"ModifierForm")),M.a.createElement(E.MDXTag,{name:"pre",components:n},M.a.createElement(E.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"import BaseForm from 'uniforms/BaseForm';\n\n// In uniforms, every form is just an injectable set of functionalities. Thus,\n// we can live without many higher order components, using composed ones\n// instead. If you want to get a deeper dive into it, read the source of\n// AutoForm or QuickForm in the core package.\nconst Modifier = parent =>\n  class extends parent {\n    // Expose injector.\n    //   It's not required, but recommended.\n    static Modifier = Modifier;\n\n    // Alter component display name.\n    //   It's not required, but recommended.\n    static displayName = `Modifier${parent.displayName}`;\n\n    // Here you can override any form methods or create additional ones.\n    getModel(mode) {\n      if (mode === 'submit') {\n        const doc = super.getModel('submit');\n        const keys = this.getChildContextSchema().getSubfields();\n\n        const update = keys.filter(key => doc[key] !== undefined);\n        const remove = keys.filter(key => doc[key] === undefined);\n\n        // It's a good idea to omit empty modifiers.\n        const $set = update.reduce((acc, key) => ({...acc, [key]: doc[key]}), {});\n        const $unset = remove.reduce((acc, key) => ({...acc, [key]: ''}), {});\n\n        return {$set, $unset};\n      }\n\n      return super.getModel(mode);\n    }\n  };\n\n// Now we have to inject our functionality. This one is a ModifierForm. Use any\n// form component you want.\nexport default Modifier(BaseForm);\n")))}}]),n}(M.a.Component)}}]);
//# sourceMappingURL=pages-forms.7bdcc2e35d2d8e0f9848.js.map